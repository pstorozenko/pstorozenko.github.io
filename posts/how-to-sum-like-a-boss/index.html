<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How to Sum Like a Boss (Almost) Σ | Pasza&#39;s blog</title>
<meta name="keywords" content="performance, summing, julia">
<meta name="description" content="In a recent post, I presented how memory layout may influence a matrix summing speed.
It&rsquo;s interesting to see that there are plenty of pitfalls we might fall into when writing sum function and memory layout is not the only one.
Please first read the previous post on summing if you haven&rsquo;t already.
Without thinking why, let&rsquo;s take a look at those two functions:">
<meta name="author" content="">
<link rel="canonical" href="/posts/how-to-sum-like-a-boss/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="/posts/how-to-sum-like-a-boss/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

>
<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>

      <script async src="https://www.googletagmanager.com/gtag/js?id=G-PR8Z9SJC7F"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-PR8Z9SJC7F');
        }
      </script><meta property="og:url" content="/posts/how-to-sum-like-a-boss/">
  <meta property="og:site_name" content="Pasza&#39;s blog">
  <meta property="og:title" content="How to Sum Like a Boss (Almost) Σ">
  <meta property="og:description" content="In a recent post, I presented how memory layout may influence a matrix summing speed. It’s interesting to see that there are plenty of pitfalls we might fall into when writing sum function and memory layout is not the only one. Please first read the previous post on summing if you haven’t already.
Without thinking why, let’s take a look at those two functions:">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-10-16T08:42:59+02:00">
    <meta property="article:modified_time" content="2021-10-16T08:42:59+02:00">
    <meta property="article:tag" content="Performance">
    <meta property="article:tag" content="Summing">
    <meta property="article:tag" content="Julia">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="How to Sum Like a Boss (Almost) Σ">
<meta name="twitter:description" content="In a recent post, I presented how memory layout may influence a matrix summing speed.
It&rsquo;s interesting to see that there are plenty of pitfalls we might fall into when writing sum function and memory layout is not the only one.
Please first read the previous post on summing if you haven&rsquo;t already.
Without thinking why, let&rsquo;s take a look at those two functions:">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/posts/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "How to Sum Like a Boss (Almost) Σ",
      "item": "/posts/how-to-sum-like-a-boss/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How to Sum Like a Boss (Almost) Σ",
  "name": "How to Sum Like a Boss (Almost) Σ",
  "description": "In a recent post, I presented how memory layout may influence a matrix summing speed. It\u0026rsquo;s interesting to see that there are plenty of pitfalls we might fall into when writing sum function and memory layout is not the only one. Please first read the previous post on summing if you haven\u0026rsquo;t already.\nWithout thinking why, let\u0026rsquo;s take a look at those two functions:\n",
  "keywords": [
    "performance", "summing", "julia"
  ],
  "articleBody": "In a recent post, I presented how memory layout may influence a matrix summing speed. It’s interesting to see that there are plenty of pitfalls we might fall into when writing sum function and memory layout is not the only one. Please first read the previous post on summing if you haven’t already.\nWithout thinking why, let’s take a look at those two functions:\nfunction sum1(A) s = zero(eltype(A)) n, m = size(A) @assert n == m sv = zeros(n) for i in 1:n for j in 1:n sv[j] += A[i, j] end end for i in 1:n s += sv[i] end return s end function sum2(A) s = zero(eltype(A)) n, m = size(A) @assert n == m sv = zeros(n) for i in 1:n for j in 1:n sv[i] += A[i, j] end end for i in 1:n s += sv[i] end return s end They are very similar to the efficient function from the previous post, but now we’re not summing into a single variable. Instead, we first calculate a sum for each row/column and then sum the intermediate row/column result. As we will soon see, adding this additional vector may change something.\nBenchmarking different summing approaches There are 4 ways of summing I’d like to compare:\nCalculate sum of each row of $A$ into vector sv and then calculate sum of sv – for_row. Calculate sum of each column of $A$ into vector sv and then calculate sum of sv – for_col. Calculate sum of the whole $A$ using one variable only (as in a previous post, IMHO the most intuitive way of summing a matrix) – simple_sum. Calculate using built-in function sum – Base.sum. Each function will be benchmarked on a random matrix $A$ which size ranges from 512 to 8192.\nFindings:\nCreating intermediate vector for sums of each row made function run 30-40% faster when compared to the simple summing function without additional vector. Creating intermediate vector for sums of each columns is slightly slower then our previous summing method. As we might expect, the built-in Base.sum function is even faster. Why creating additional array made function run faster? Finding #1 So this is one of these problems where at first results are strange, but a moment later they’re obvious. The key factor is a low-level parallelization that the processor is able to perform when calculating sums for rows.\nFirst, observe that in general, the summing operation is not parallelizable. If you want to calculate sum of array $[1, 2, 3, 4]$ by visiting each element in turn, you have to calculate $0 + 1$, $1 + 2$, then $3 + 3$ and finally $6 + 4$. You could at one time calculate $1 + 2$ and $3 + 4$, and then do $3 + 7$ but it would require jumping over the array.\nNot let’s remind that julia has F-style memory layout with a matrix being stored as a sequence of columns. This means (as discussed in a previous post) that to iterate along the memory, we have to iterate with the outer loop over columns and the inner over rows.\nImagine that you have to sum elements of the following matrix $A$:\n$$ A = \\begin{pmatrix} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\\\ 7 \u0026 8 \u0026 9 \\end{pmatrix} $$\nby traversing it’s elements in the above order i.e. traversing a vector $A_F = [1,4,7,2,5,8,3,6,9]$.\nIf we would like to calculate sum of $1+4+7$ first into sv[1] you throttle on access to sv[1] element. Computer have to wait for the result of $1+4$ until it is able to add $7$. Please note that after we’re done with column 1, sv[1] is not used any more except for the final sv summing.\nCalculating sum of rows is a different story however! Processor can simultaneously add $1$ to sv[1], $4$ to sv[2] and $7$ to sv[3]. Only then it has to wait until $1$ is added to sv[1] to proceed with the second column. And the third. Finally there is a place for optimization. The only throttling operation is calculating the sum of sv vector in the end.\nFinding #2 This one is rather obvious, small overhead has been added with this new vector without any place for optimization.\nFinding #3 I was curious how sum is performed in julia and I was surprised by the level of it’s both beauty and complexity.\nThe beauty lies in the form that sum(A) is more or less defined as reduce(+, A), which is mapreduce(identity, +, A). This makes functions sum and prod(A) = reduce(*, A) function (probably also a few more) share almost the whole code base (prod is product, i.e. prod([2, 3, 4]) == 24).\nComplexity lies in a way mapreduce function is written. This implementation takes advantage of low-level optimizations.\nHow should I write my code based on these experiments In this post, we discovered another thing to keep in mind when writing high-performance code. First, try to use built-in methods when possible. Second, try to design the function in a way that there is no way for throttling on access to a single variable. Thinking in this way also allows performing some higher-level optimization when necessary.\nAs always, code available on GitHub.\n",
  "wordCount" : "873",
  "inLanguage": "en",
  "datePublished": "2021-10-16T08:42:59+02:00",
  "dateModified": "2021-10-16T08:42:59+02:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/posts/how-to-sum-like-a-boss/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Pasza's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Pasza&#39;s blog (Alt + H)">Pasza&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="/about" title="About me">
                    <span>About me</span>
                </a>
            </li>
            <li>
                <a href="/useful-materials" title="Useful materials">
                    <span>Useful materials</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      How to Sum Like a Boss (Almost) Σ
    </h1>
    <div class="post-meta"><span title='2021-10-16 08:42:59 +0200 +0200'>October 16, 2021</span>

</div>
  </header> 
  <div class="post-content"><p>In a recent post, I presented how memory layout may influence a matrix summing speed.
It&rsquo;s interesting to see that there are plenty of pitfalls we might fall into when writing sum function and memory layout is not the only one.
Please first <a href="/posts/speed-of-traversing-matrix/" title="Post on summing by rows vs cols first">read the previous post on summing</a> if you haven&rsquo;t already.</p>
<p>Without thinking <em>why</em>, let&rsquo;s take a look at those two functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> sum1(A)
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">=</span> zero(eltype(A))
</span></span><span style="display:flex;"><span>    n, m <span style="color:#f92672">=</span> size(A)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@assert</span> n <span style="color:#f92672">==</span> m
</span></span><span style="display:flex;"><span>    sv <span style="color:#f92672">=</span> zeros(n)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>n
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>n
</span></span><span style="display:flex;"><span>            sv[j] <span style="color:#f92672">+=</span> A[i, j]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>n
</span></span><span style="display:flex;"><span>        s <span style="color:#f92672">+=</span> sv[i]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> s
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> sum2(A)
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">=</span> zero(eltype(A))
</span></span><span style="display:flex;"><span>    n, m <span style="color:#f92672">=</span> size(A)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@assert</span> n <span style="color:#f92672">==</span> m
</span></span><span style="display:flex;"><span>    sv <span style="color:#f92672">=</span> zeros(n)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>n
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>n
</span></span><span style="display:flex;"><span>            sv[i] <span style="color:#f92672">+=</span> A[i, j]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>n
</span></span><span style="display:flex;"><span>        s <span style="color:#f92672">+=</span> sv[i]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> s
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>They are very similar to the <em>efficient</em> function from the previous post, but now we&rsquo;re not summing into a single variable.
Instead, we <strong>first calculate a sum for each row/column</strong> and then sum the intermediate row/column result.
As we will soon see, adding this additional vector <em>may change something</em>.</p>
<h2 id="benchmarking-different-summing-approaches">Benchmarking different summing approaches<a hidden class="anchor" aria-hidden="true" href="#benchmarking-different-summing-approaches">#</a></h2>
<p>There are 4 ways of summing I&rsquo;d like to compare:</p>
<ol>
<li>Calculate sum of each <strong>row</strong> of $A$ into vector <code>sv</code> and then calculate sum of <code>sv</code> &ndash; <code>for_row</code>.</li>
<li>Calculate sum of each <strong>column</strong> of $A$ into vector <code>sv</code> and then calculate sum of <code>sv</code> &ndash; <code>for_col</code>.</li>
<li>Calculate sum of the whole $A$ using <strong>one variable</strong> only (as in a previous post, IMHO the most intuitive way of summing a matrix) &ndash; <code>simple_sum</code>.</li>
<li>Calculate using <strong>built-in</strong> function <code>sum</code> &ndash; <code>Base.sum</code>.</li>
</ol>
<p>Each function will be benchmarked on a random matrix $A$ which size ranges from 512 to 8192.</p>
<p><img alt="Benchmark" loading="lazy" src="/posts/how-to-sum-like-a-boss/benchmark.png"></p>
<p>Findings:</p>
<ol>
<li>Creating intermediate vector for sums of each row <strong>made function run 30-40% faster</strong> when compared to the simple summing function without additional vector.</li>
<li>Creating intermediate vector for sums of each columns is <strong>slightly slower</strong> then our previous summing method.</li>
<li>As we might expect, the built-in <code>Base.sum</code> function is <strong>even faster</strong>.</li>
</ol>
<h2 id="why-creating-additional-array-made-function-run-faster">Why creating additional array made function run faster?<a hidden class="anchor" aria-hidden="true" href="#why-creating-additional-array-made-function-run-faster">#</a></h2>
<h3 id="finding-1">Finding #1<a hidden class="anchor" aria-hidden="true" href="#finding-1">#</a></h3>
<p>So this is one of these problems where at first results are strange, but a moment later they&rsquo;re obvious.
The key factor is a low-level parallelization that the processor is able to perform when calculating sums for rows.</p>
<p>First, observe that in general, the summing operation is not parallelizable.
If you want to calculate sum of array $[1, 2, 3, 4]$ by visiting each element in turn, you have to calculate $0 + 1$, $1 + 2$, then $3 + 3$ and finally $6 + 4$.
You could at one time calculate $1 + 2$ and $3 + 4$, and then do $3 + 7$ but it would require <em>jumping</em> over the array.</p>
<p>Not let&rsquo;s remind that julia has F-style memory layout with a matrix being stored as a sequence of columns.
This means (as discussed in a previous post) that to iterate along the memory, we have to iterate with the outer loop over columns and the inner over rows.</p>
<p>Imagine that you have to sum elements of the following matrix $A$:</p>
<p>$$
A = \begin{pmatrix}
1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\  7 &amp; 8 &amp; 9
\end{pmatrix}
$$</p>
<p>by traversing it&rsquo;s elements in the above order i.e. traversing a vector $A_F = [1,4,7,2,5,8,3,6,9]$.</p>
<p>If we would like to calculate sum of $1+4+7$ first into <code>sv[1]</code> you throttle on access to <code>sv[1]</code> element.
Computer have to wait for the result of $1+4$ until it is able to add $7$.
Please note that after we&rsquo;re done with column 1, <code>sv[1]</code> is not used any more except for the final <code>sv</code> summing.</p>
<p>Calculating sum of rows is a different story however!
Processor can simultaneously add $1$ to <code>sv[1]</code>, $4$ to <code>sv[2]</code> and $7$ to <code>sv[3]</code>.
Only then it has to wait until $1$ is added to <code>sv[1]</code> to proceed with the second column. And the third.
Finally there is a place for optimization.
The only throttling operation is calculating the sum of <code>sv</code> vector in the end.</p>
<h3 id="finding-2">Finding #2<a hidden class="anchor" aria-hidden="true" href="#finding-2">#</a></h3>
<p>This one is rather obvious, small overhead has been added with this new vector without any place for optimization.</p>
<h3 id="finding-3">Finding #3<a hidden class="anchor" aria-hidden="true" href="#finding-3">#</a></h3>
<p>I was curious how <code>sum</code> is performed in julia and I was surprised by the level of it&rsquo;s both beauty and complexity.</p>
<p>The beauty lies in the form that <code>sum(A)</code> is more or less defined as <code>reduce(+, A)</code>, which is <code>mapreduce(identity, +, A)</code>.
This makes functions <code>sum</code> and <code>prod(A) = reduce(*, A)</code> function (probably also a few more) share almost the whole code base (<code>prod</code> is product, i.e. <code>prod([2, 3, 4]) == 24</code>).</p>
<p>Complexity lies in <a href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/reduce.jl#L605-L645">a way <code>mapreduce</code> function is written</a>.
This implementation takes advantage of low-level optimizations.</p>
<h2 id="how-should-i-write-my-code-based-on-these-experiments">How should I write my code based on these experiments<a hidden class="anchor" aria-hidden="true" href="#how-should-i-write-my-code-based-on-these-experiments">#</a></h2>
<p>In this post, we discovered another thing to keep in mind when writing high-performance code.
First, try to use built-in methods when possible.
Second, try to design the function in a way that there is no way for throttling on access to a single variable.
Thinking in this way also allows performing some higher-level optimization when necessary.</p>
<p><a href="https://github.com/pstorozenko/pstorozenko.github.io/tree/main/code/how-to-sum-like-a-boss">As always, code available on GitHub.</a></p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="/tags/performance/">Performance</a></li>
      <li><a href="/tags/summing/">Summing</a></li>
      <li><a href="/tags/julia/">Julia</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>Piotr Pasza Storożenko</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
