<!doctype html><html lang=en>
<head>
<title>
How to Sum Like a Boss (Almost) Σ ::
Pasza's blog — a simple blog about complex things
</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="In a recent post, I presented how memory layout may influence a matrix summing speed. It&amp;rsquo;s interesting to see that there are plenty of pitfalls we might fall into when writing sum function and memory layout is not the only one. Please first read the previous post on summing if you haven&amp;rsquo;t already.
Without thinking why, let&amp;rsquo;s take a look at those two functions:
">
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=/posts/how-to-sum-like-a-boss/>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.css integrity=sha384-ysFyB7Is//Q1JNgERb0bLJokXKM8eWJsjEutGvthoHtBilHWgbdmbYkQZdwCIGIq crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.js integrity=sha384-UWjC+k927Mtx6WQF5SzKTXLLrOYmzs69HvkUjiKvUwSOljzc+C6PrGquNpOvJBBo crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PR8Z9SJC7F"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-PR8Z9SJC7F',{anonymize_ip:!1})}</script>
<link rel=stylesheet href=/assets/style.css>
<link rel=stylesheet href=/style.css>
<link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png>
<link rel="shortcut icon" href=/img/favicon.png>
<link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="How to Sum Like a Boss (Almost) Σ">
<meta name=twitter:description content="In a recent post, I presented how memory layout may influence a matrix summing speed.
It&rsquo;s interesting to see that there are plenty of pitfalls we might fall into when writing sum function and memory layout is not the only one.
Please first read the previous post on summing if you haven&rsquo;t already.
Without thinking why, let&rsquo;s take a look at those two functions:">
<meta property="og:title" content="How to Sum Like a Boss (Almost) Σ">
<meta property="og:description" content="In a recent post, I presented how memory layout may influence a matrix summing speed.
It&rsquo;s interesting to see that there are plenty of pitfalls we might fall into when writing sum function and memory layout is not the only one.
Please first read the previous post on summing if you haven&rsquo;t already.
Without thinking why, let&rsquo;s take a look at those two functions:">
<meta property="og:type" content="article">
<meta property="og:url" content="/posts/how-to-sum-like-a-boss/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-10-16T08:42:59+02:00">
<meta property="article:modified_time" content="2021-10-16T08:42:59+02:00"><meta property="og:site_name" content="Pasza's blog">
</head>
<body>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ class=logo style=text-decoration:none>
<span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span>
<span class=logo__text>pasza's blog</span>
<span class=logo__cursor></span>
</a>
<span class=header__right>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/about>About me</a></li>
<li><a href=/useful-materials>Useful materials</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/about>About me</a></li>
<li><a href=/useful-materials>Useful materials</a></li>
</ul>
</nav>
<span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span>
<span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg>
</span>
</span>
</span>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>How to Sum Like a Boss (Almost) Σ</h1>
<div class=post-meta>
<span class=post-date>
2021-10-16
</span>
</div>
<span class=post-tags>
<a href=/tags/performance/>#performance</a>&nbsp;
<a href=/tags/summing/>#summing</a>&nbsp;
<a href=/tags/julia/>#julia</a>&nbsp;
</span>
<div class=post-content>
<p>In a recent post, I presented how memory layout may influence a matrix summing speed.
It&rsquo;s interesting to see that there are plenty of pitfalls we might fall into when writing sum function and memory layout is not the only one.
Please first <a href=/posts/speed-of-traversing-matrix/ title="Post on summing by rows vs cols first">read the previous post on summing</a> if you haven&rsquo;t already.</p>
<p>Without thinking <em>why</em>, let&rsquo;s take a look at those two functions:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=color:#66d9ef>function</span> sum1(A)
    s <span style=color:#f92672>=</span> zero(eltype(A))
    n, m <span style=color:#f92672>=</span> size(A)
    <span style=color:#a6e22e>@assert</span> n <span style=color:#f92672>==</span> m
    sv <span style=color:#f92672>=</span> zeros(n)
    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>n
        <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>n
            sv[j] <span style=color:#f92672>+=</span> A[i, j]
        <span style=color:#66d9ef>end</span>
    <span style=color:#66d9ef>end</span>
    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>n
        s <span style=color:#f92672>+=</span> sv[i]
    <span style=color:#66d9ef>end</span>
    <span style=color:#66d9ef>return</span> s
<span style=color:#66d9ef>end</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=color:#66d9ef>function</span> sum2(A)
    s <span style=color:#f92672>=</span> zero(eltype(A))
    n, m <span style=color:#f92672>=</span> size(A)
    <span style=color:#a6e22e>@assert</span> n <span style=color:#f92672>==</span> m
    sv <span style=color:#f92672>=</span> zeros(n)
    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>n
        <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>n
            sv[i] <span style=color:#f92672>+=</span> A[i, j]
        <span style=color:#66d9ef>end</span>
    <span style=color:#66d9ef>end</span>
    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>n
        s <span style=color:#f92672>+=</span> sv[i]
    <span style=color:#66d9ef>end</span>
    <span style=color:#66d9ef>return</span> s
<span style=color:#66d9ef>end</span>
</code></pre></div><p>They are very similar to the <em>efficient</em> function from the previous post, but now we&rsquo;re not summing into a single variable.
Instead, we <strong>first calculate a sum for each row/column</strong> and then sum the intermediate row/column result.
As we will soon see, adding this additional vector <em>may change something</em>.</p>
<h2 id=benchmarking-different-summing-approaches>Benchmarking different summing approaches</h2>
<p>There are 4 ways of summing I&rsquo;d like to compare:</p>
<ol>
<li>Calculate sum of each <strong>row</strong> of $A$ into vector <code>sv</code> and then calculate sum of <code>sv</code> &ndash; <code>for_row</code>.</li>
<li>Calculate sum of each <strong>column</strong> of $A$ into vector <code>sv</code> and then calculate sum of <code>sv</code> &ndash; <code>for_col</code>.</li>
<li>Calculate sum of the whole $A$ using <strong>one variable</strong> only (as in a previous post, IMHO the most intuitive way of summing a matrix) &ndash; <code>simple_sum</code>.</li>
<li>Calculate using <strong>built-in</strong> function <code>sum</code> &ndash; <code>Base.sum</code>.</li>
</ol>
<p>Each function will be benchmarked on a random matrix $A$ which size ranges from 512 to 8192.</p>
<p><img src=/posts/how-to-sum-like-a-boss/benchmark.png alt=Benchmark></p>
<p>Findings:</p>
<ol>
<li>Creating intermediate vector for sums of each row <strong>made function run 30-40% faster</strong> when compared to the simple summing function without additional vector.</li>
<li>Creating intermediate vector for sums of each columns is <strong>slightly slower</strong> then our previous summing method.</li>
<li>As we might expect, the built-in <code>Base.sum</code> function is <strong>even faster</strong>.</li>
</ol>
<h2 id=why-creating-additional-array-made-function-run-faster>Why creating additional array made function run faster?</h2>
<h3 id=finding-1>Finding #1</h3>
<p>So this is one of these problems where at first results are strange, but a moment later they&rsquo;re obvious.
The key factor is a low-level parallelization that the processor is able to perform when calculating sums for rows.</p>
<p>First, observe that in general, the summing operation is not parallelizable.
If you want to calculate sum of array $[1, 2, 3, 4]$ by visiting each element in turn, you have to calculate $0 + 1$, $1 + 2$, then $3 + 3$ and finally $6 + 4$.
You could at one time calculate $1 + 2$ and $3 + 4$, and then do $3 + 7$ but it would require <em>jumping</em> over the array.</p>
<p>Not let&rsquo;s remind that julia has F-style memory layout with a matrix being stored as a sequence of columns.
This means (as discussed in a previous post) that to iterate along the memory, we have to iterate with the outer loop over columns and the inner over rows.</p>
<p>Imagine that you have to sum elements of the following matrix $A$:</p>
<p>$$
A = \begin{pmatrix}
1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9
\end{pmatrix}
$$</p>
<p>by traversing it&rsquo;s elements in the above order i.e. traversing a vector $A_F = [1,4,7,2,5,8,3,6,9]$.</p>
<p>If we would like to calculate sum of $1+4+7$ first into <code>sv[1]</code> you throttle on access to <code>sv[1]</code> element.
Computer have to wait for the result of $1+4$ until it is able to add $7$.
Please note that after we&rsquo;re done with column 1, <code>sv[1]</code> is not used any more except for the final <code>sv</code> summing.</p>
<p>Calculating sum of rows is a different story however!
Processor can simultaneously add $1$ to <code>sv[1]</code>, $4$ to <code>sv[2]</code> and $7$ to <code>sv[3]</code>.
Only then it has to wait until $1$ is added to <code>sv[1]</code> to proceed with the second column. And the third.
Finally there is a place for optimization.
The only throttling operation is calculating the sum of <code>sv</code> vector in the end.</p>
<h3 id=finding-2>Finding #2</h3>
<p>This one is rather obvious, small overhead has been added with this new vector without any place for optimization.</p>
<h3 id=finding-3>Finding #3</h3>
<p>I was curious how <code>sum</code> is performed in julia and I was surprised by the level of it&rsquo;s both beauty and complexity.</p>
<p>The beauty lies in the form that <code>sum(A)</code> is more or less defined as <code>reduce(+, A)</code>, which is <code>mapreduce(identity, +, A)</code>.
This makes functions <code>sum</code> and <code>prod(A) = reduce(*, A)</code> function (probably also a few more) share almost the whole code base (<code>prod</code> is product, i.e. <code>prod([2, 3, 4]) == 24</code>).</p>
<p>Complexity lies in <a href=https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/reduce.jl#L605-L645>a way <code>mapreduce</code> function is written</a>.
This implementation takes advantage of low-level optimizations.</p>
<h2 id=how-should-i-write-my-code-based-on-these-experiments>How should I write my code based on these experiments</h2>
<p>In this post, we discovered another thing to keep in mind when writing high-performance code.
First, try to use built-in methods when possible.
Second, try to design the function in a way that there is no way for throttling on access to a single variable.
Thinking in this way also allows performing some higher-level optimization when necessary.</p>
</div>
<div class=pagination>
<div class=pagination__title>
<span class=pagination__title-h>Read other posts</span>
<hr>
</div>
<div class=pagination__buttons>
<span class="button next">
<a href=/posts/ml-data-versioning-with-dvc/>
<span class=button__text>ML Data Versioning With DVC: How to manage machine learning data 🗃</span>
<span class=button__icon>→</span>
</a>
</span>
</div>
</div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user">Piotr Pasza Storożenko</div>
</div>
</footer>
<script src=/assets/main.js></script>
<script src=/assets/prism.js></script>
</div>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PR8Z9SJC7F"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-PR8Z9SJC7F',{anonymize_ip:!1})}</script>
</body>
</html>